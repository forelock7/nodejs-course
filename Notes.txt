////////////////////////////////////////////////////////////////////////////////////////////////
Section 2: V8: The Javascript Engine
////////////////////////////////////////////////////////////////////////////////////////////////

- Levels of programmig language

1. Machine Language
2. Assembly Language
3. C/C++
4. JavaScript

- Node is written in C++
- V8 is written in C++

- ECMAScript - standart Javascript is based on
- JavaScript - language

- JavaScript engine - program taht converts JS code into something the computer precessor can understand.

- V8 is Google's open source JavaSript engine. Written in C++. Implements ECMAScript as specified. I was create d to execute in Chrome browser

- JavaScript Code -> V8 engine(converts/interprete/compile) -> Machine Code

////////////////////////////////////////////////////////////////////////////////////////////////
Section 3: The Node Core
////////////////////////////////////////////////////////////////////////////////////////////////

- Client(Browser - JS) <--HTTP--> Server(WebServer - Js)

- Run NodeJS file:
  node app.js

////////////////////////////////////////////////////////////////////////////////////////////////
Section 4: Modules, Exports, and Require
////////////////////////////////////////////////////////////////////////////////////////////////

- Main objects:

1. Modules - reusable block of code (impact other code).
2. Exports
3. Require

- Commonjs modules - an agreed upon standart for how code modules should be structured

- First-Class Function - everything you can do with other types you can do with functions. You can use functions like string, numbers, etc. (i.e. pass them around, set variables equal to them, put them in arrays ...)

- Function Expression - a block of code that results in a value. Function expressions are possible in JS because functions are first-class.

- function statement (declaration)
  function greet() {
  console.log("hi");
  }
  greet();

- function are first-class
  function logGreeting(fn) {
  fn();
  }
  logGreeting(greet);

- function expression
  var greetMe = function () {
  console.log("Hi Vova");
  };
  greetMe();
- It's still first-class
  logGreeting(greetMe);

// use a function expression on the fly
logGreeting(function () {
console.log("Hello Tony");
});

- Use module in another JS script file
  require("./greet.js");

- Not only execute all in module, but also get/invoke particular func
- Module (greet.js)
  var greet = function () {
  console.log("Hello!");
  };
  module.exports = greet;
- JS file (app.js)
  var greet = require("./greet");
  greet();

- Local variables for each JS script file
  **dirname
  **filename
  exports
  module
  require
  this

- Name/Value pair - a name which maps to a value. The name may be defines more than once, but only can have one value in any given context. That value may be more name/value pairs.
Address = 'Main Street'

- Object - collection of name/value pairs
+ Primitive(property)
+ Object(property)
+ Function(method)

- Object literal - name/vale pairs separated by commas and surrounded by curly braces. This is just a quick, shorthand way to create JS object in code
{
  Street: 'Main',
  Number: 100,
  App: {
    num: 4,
  }
}

- Get propertis from object
var person = {
  firstname: "John",
  lastname: "Doe",
  greet: function () {
    console.log("Hello, " + this.firstname + " " + this.lastname);
  },
};
person.greet();
person["firstname"];

- Inheritance implemented by Prototype chain via proto property
prototype - function
__proto__ - property
function Person(firstname, lastname) {
  this.firstname = firstname;
  this.lastname = lastname;
}
Person.prototype.greet = function () {
  console.log('Hello, ' + this.firstname + ' ' + this.lastname);
};
var john = new Person('John', 'Doe');
console.log(john.__proto__);

- Primitive - a type of data that represents a single value, like a number or a string, not a object.

- Primitive - pass by value
- Objects - pass by reference

-  Scope - where in code you have access to particular var of function

- immediately invoked function expression
(function() {
}())

- if we use require, it actually take all code from that module and wrapped it into an immediately invoked function expression
var greet = require('./greet');
greet();
- IIFE:
(function (exports, require, module, __filename, __dirname) {
  var greet = function() {
	console.log('Hello!');
};
module.exports = greet;
});

- JSON - JS Object Notation

- set function to empty 'export' object and call it
module.exports = function () {
  console.log('Hello World');
};
--------
var greet = require('./greet1');
greet();

- set function to 'greet' property of 'export' object and call it
module.exports.greet = function () {
  console.log('Hello World');
};
------
var greet2 = require('./greet2').greet;
greet2();

- set object to empty 'export' object and call it
function Greetr() {
  this.greeting = 'Hello world!!';
  this.greet = function () {
    console.log(this.greeting);
  };
}
module.exports = new Greetr();
----
var greet3 = require('./greet3');
greet3.greet();

- if we call require with object - we'll get the same object because it is cached.
greet3.greeting = 'Changed Hello world!!';
var greet3b = require('./greet3');
greet3b.greet(); // Changed Hello world!!

- To avoid caching just export not object, but constructor
function Greetr() {
  this.greeting = 'Hello world!!!';
  this.greet = function () {
    console.log(this.greeting);
  };
}
module.exports = Greetr;
-----
var Greet4 = require('./greet4');
var grtr = new Greet4();
grtr.greet();

- revieling module pattern - exposing only the cproperties and methods you want via an returned object
var greeting = 'Hello world!!!!';
function greet() {
  console.log(greeting);
}
module.exports = {
  greet: greet,
};
-----
var greet5 = require('./greet5').greet;
greet5();

- In JS if variable set equal to value - new object created

- Mutate - to change something

////////////////////////////////////////////////////////////////////////////////////////////////
Section 5: Events and the Event Emitter
////////////////////////////////////////////////////////////////////////////////////////////////

- Call of object property:
obj.greet;
obj['greet'];

- You can put function as item to array

- Event Listener - code that responds to Event

- magic string - string that has some special meaning in our code. This is bad because it makes it easy for a typo to cause a bug, and hard tools to help us find it.

- Object.create method by existing object
var person = {
  firstname: '',
  lastname: '',
  greet: function () {
    return this.firstname + ' ' + this.lastname;
  },
};
var john = Object.create(person);

- babeljs.io - convert new syntex (ES6) to old versions (NodeJS, ES5) for old versions of browsers

- Template Literal - a way to concatenate strings in JS (ES6). Easier to work with than a bunch of strings concatenated with '+'. It used backticks:
`Hallo ${name}` 

- call methods within differetn oblects:
var obj = {
  name: 'John Doe',
  greet: function () {
    console.log(`Hello ${this.name}`);
  },
};
obj.greet();
obj.greet.call({ name: 'Jane Doe' }, param, param2);
obj.greet.apply({ name: 'Jane Amm Doe' }, [param, param2]);

- Classes - feature of ES6

- Syntactic sugar - a feature that only changes how you type something, but nothing changes under the hood

- Inheritance (Nodejs, ES5):
function Page() {
  BasePage.call(this);
  this.headerLocator = '/h'
}
util.inherits(Page, BasePage)

- Inheritance (ES6):
class Page extends BasePage{
  constructor() {
    super()
    this.headerLocator = '/div'
  }
}